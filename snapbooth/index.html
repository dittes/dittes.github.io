<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>SnapBooth</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0c;
  --surface: #141418;
  --surface2: #1e1e24;
  --border: #2a2a35;
  --accent: #f0a030;
  --accent2: #e05020;
  --text: #f0ede8;
  --text-dim: #7a7880;
  --red: #e03030;
  --green: #30c060;
  --radius: 12px;
  --film-h: 110px;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font-family: 'DM Mono', monospace;
  overflow: hidden;
}

#app {
  display: flex;
  flex-direction: column;
  height: 100dvh;
  max-height: 100dvh;
  position: relative;
}

/* â”€â”€â”€ HEADER â”€â”€â”€ */
#header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 10;
}
#logo {
  font-family: 'Syne', sans-serif;
  font-weight: 800;
  font-size: 1.3rem;
  letter-spacing: -0.02em;
  color: var(--accent);
}
#logo span { color: var(--text); }
#header-right {
  display: flex;
  gap: 8px;
  align-items: center;
}
.icon-btn {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 8px;
  width: 36px; height: 36px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  transition: all 0.15s;
  font-size: 16px;
}
.icon-btn:hover { color: var(--text); border-color: var(--accent); }
.icon-btn.active { color: var(--accent); border-color: var(--accent); background: rgba(240,160,48,0.1); }

/* â”€â”€â”€ MAIN AREA â”€â”€â”€ */
#main {
  flex: 1;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

#canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#preview-canvas {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  border-radius: var(--radius);
  cursor: crosshair;
  display: block;
}

#video-source {
  position: absolute;
  width: 1px; height: 1px;
  opacity: 0;
  pointer-events: none;
}

/* â”€â”€â”€ OVERLAYS â”€â”€â”€ */
#countdown-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 20;
  opacity: 0;
}
#countdown-num {
  font-family: 'Syne', sans-serif;
  font-size: clamp(80px, 20vw, 200px);
  font-weight: 800;
  color: white;
  text-shadow: 0 0 40px rgba(240,160,48,0.8), 0 4px 30px rgba(0,0,0,0.5);
  transform: scale(0.5);
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
}
#countdown-overlay.show { opacity: 1; }
#countdown-overlay.show #countdown-num { transform: scale(1); }

#flash-overlay {
  position: absolute;
  inset: 0;
  background: white;
  z-index: 30;
  pointer-events: none;
  opacity: 0;
  border-radius: var(--radius);
}
#flash-overlay.flash { animation: doFlash 0.35s ease-out forwards; }
@keyframes doFlash {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* 4-up grid overlay during capture */
#fourUp-indicator {
  position: absolute;
  top: 12px; right: 12px;
  background: rgba(0,0,0,0.7);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 11px;
  color: var(--accent);
  display: none;
  z-index: 25;
}
#fourUp-indicator.show { display: block; }

/* Focal point indicator */
#focal-point {
  position: absolute;
  width: 40px; height: 40px;
  border: 2px solid rgba(255,255,255,0.6);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 15;
  display: none;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.4);
}
#focal-point::before, #focal-point::after {
  content: '';
  position: absolute;
  background: rgba(255,255,255,0.6);
}
#focal-point::before { width: 1px; height: 12px; left: 50%; top: -14px; transform: translateX(-50%); }
#focal-point::after { width: 12px; height: 1px; top: 50%; left: -14px; transform: translateY(-50%); }
#focal-point.show { display: block; }

/* Distortion slider overlay */
#distortion-slider-wrap {
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 20;
  display: none;
  background: rgba(10,10,12,0.85);
  backdrop-filter: blur(8px);
  border: 1px solid var(--border);
  border-radius: 24px;
  padding: 10px 20px;
  align-items: center;
  gap: 12px;
  min-width: 240px;
}
#distortion-slider-wrap.show { display: flex; }
#distortion-slider-wrap label { font-size: 11px; color: var(--text-dim); white-space: nowrap; }
#distortion-amount {
  -webkit-appearance: none;
  appearance: none;
  flex: 1;
  height: 4px;
  background: var(--border);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}
#distortion-amount::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px; height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}
#distortion-amount::-moz-range-thumb {
  width: 16px; height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: none;
}

/* â”€â”€â”€ EFFECTS PANEL â”€â”€â”€ */
#effects-panel {
  position: absolute;
  inset: 0;
  background: rgba(10,10,12,0.95);
  backdrop-filter: blur(12px);
  z-index: 40;
  display: none;
  flex-direction: column;
  padding: 16px;
  gap: 12px;
  overflow: hidden;
}
#effects-panel.open { display: flex; }

#effects-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
#effects-header h2 {
  font-family: 'Syne', sans-serif;
  font-weight: 700;
  font-size: 1rem;
  color: var(--text);
  letter-spacing: 0.05em;
  text-transform: uppercase;
}
#close-effects {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 6px;
  padding: 4px 12px;
  cursor: pointer;
  font-family: inherit;
  font-size: 12px;
  transition: all 0.15s;
}
#close-effects:hover { color: var(--text); border-color: var(--text); }

#effects-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}

.effect-tile {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  border: 2px solid transparent;
  transition: border-color 0.2s, transform 0.15s;
  aspect-ratio: 4/3;
  background: var(--surface2);
}
.effect-tile:hover { transform: scale(1.03); }
.effect-tile.selected { border-color: var(--accent); }
.effect-tile canvas {
  width: 100%; height: 100%;
  object-fit: cover;
  display: block;
}
.effect-tile-label {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  background: linear-gradient(transparent, rgba(0,0,0,0.8));
  padding: 16px 6px 5px;
  font-size: 10px;
  color: white;
  text-align: center;
  letter-spacing: 0.04em;
}

#effects-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
}
.nav-arrow {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 50%;
  width: 32px; height: 32px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  transition: all 0.15s;
  font-size: 14px;
}
.nav-arrow:hover { border-color: var(--accent); color: var(--accent); }
.nav-arrow:disabled { opacity: 0.3; cursor: default; }
#page-dots { display: flex; gap: 6px; }
.page-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--border);
  transition: background 0.2s;
  cursor: pointer;
}
.page-dot.active { background: var(--accent); }

/* â”€â”€â”€ VIEWER OVERLAY â”€â”€â”€ */
#viewer-overlay {
  position: absolute;
  inset: 0;
  background: rgba(10,10,12,0.97);
  z-index: 50;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  gap: 16px;
}
#viewer-overlay.open { display: flex; }
#viewer-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 0;
}
#viewer-img {
  max-width: 100%; max-height: 100%;
  border-radius: var(--radius);
  object-fit: contain;
  cursor: pointer;
}
#viewer-fourUp {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
  max-height: 100%;
  max-width: 100%;
  width: 100%;
}
#viewer-fourUp img {
  width: 100%; height: 100%;
  object-fit: cover;
  border-radius: 6px;
  cursor: pointer;
  transition: transform 0.2s;
}
#viewer-fourUp img:hover { transform: scale(1.02); }
#viewer-bottom {
  display: flex;
  gap: 10px;
  align-items: center;
}
.viewer-btn {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 8px;
  padding: 8px 18px;
  cursor: pointer;
  font-family: inherit;
  font-size: 12px;
  transition: all 0.15s;
}
.viewer-btn:hover { border-color: var(--accent); color: var(--accent); }
.viewer-btn.primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 500; }
.viewer-btn.primary:hover { background: #d08820; }
.viewer-btn.danger { border-color: var(--red); color: var(--red); }
.viewer-btn.danger:hover { background: rgba(224,48,48,0.1); }

/* â”€â”€â”€ BOTTOM BAR â”€â”€â”€ */
#bottom-bar {
  background: var(--surface);
  border-top: 1px solid var(--border);
  padding: 10px 16px 12px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#controls-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* Mode buttons */
#mode-group {
  display: flex;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
}
.mode-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  padding: 6px 12px;
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
  letter-spacing: 0.04em;
}
.mode-btn:not(:last-child) { border-right: 1px solid var(--border); }
.mode-btn.active {
  background: var(--accent);
  color: #000;
  font-weight: 500;
}

/* Shutter button */
#shutter-btn {
  width: 60px; height: 60px;
  border-radius: 50%;
  border: 3px solid white;
  background: white;
  cursor: pointer;
  position: relative;
  transition: transform 0.1s, background 0.1s;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 0 4px rgba(255,255,255,0.15);
}
#shutter-btn:hover { transform: scale(1.05); }
#shutter-btn:active { transform: scale(0.95); }
#shutter-btn .shutter-inner {
  width: 44px; height: 44px;
  border-radius: 50%;
  background: white;
  transition: background 0.15s;
}
#shutter-btn.recording { border-color: var(--red); box-shadow: 0 0 0 4px rgba(224,48,48,0.25); }
#shutter-btn.recording .shutter-inner {
  background: var(--red);
  border-radius: 6px;
  width: 22px; height: 22px;
}

/* Effects toggle */
#effects-btn {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 8px;
  padding: 8px 14px;
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  letter-spacing: 0.04em;
  display: flex;
  align-items: center;
  gap: 6px;
}
#effects-btn:hover { color: var(--text); border-color: var(--accent); }
#effects-btn.active { color: var(--accent); border-color: var(--accent); background: rgba(240,160,48,0.1); }

/* Current effect indicator */
#current-effect-name {
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  text-align: center;
  height: 12px;
}

/* â”€â”€â”€ FILMSTRIP â”€â”€â”€ */
#filmstrip {
  height: var(--film-h);
  display: flex;
  gap: 6px;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 2px 4px;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
  flex-shrink: 0;
}
#filmstrip::-webkit-scrollbar { height: 3px; }
#filmstrip::-webkit-scrollbar-track { background: transparent; }
#filmstrip::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#filmstrip-empty {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-dim);
  font-size: 11px;
  letter-spacing: 0.04em;
}

.film-item {
  position: relative;
  flex-shrink: 0;
  height: calc(var(--film-h) - 8px);
  aspect-ratio: 4/3;
  border-radius: 6px;
  overflow: hidden;
  cursor: pointer;
  border: 2px solid var(--border);
  transition: border-color 0.2s, transform 0.2s;
  background: var(--surface2);
}
.film-item:hover { border-color: var(--accent); transform: translateY(-2px); }
.film-item img, .film-item video {
  width: 100%; height: 100%;
  object-fit: cover;
  display: block;
}
.film-item-badge {
  position: absolute;
  top: 3px; right: 3px;
  background: rgba(0,0,0,0.7);
  border-radius: 3px;
  padding: 1px 4px;
  font-size: 8px;
  color: var(--accent);
  letter-spacing: 0.04em;
}
.film-item-new {
  animation: slideIn 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}
@keyframes slideIn {
  from { transform: scale(0.6) translateY(20px); opacity: 0; }
  to { transform: scale(1) translateY(0); opacity: 1; }
}

/* â”€â”€â”€ PERMISSION ERROR â”€â”€â”€ */
#permission-error {
  position: absolute;
  inset: 0;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  z-index: 60;
  background: var(--bg);
  padding: 32px;
  text-align: center;
}
#permission-error.show { display: flex; }
#permission-error .err-icon { font-size: 48px; margin-bottom: 8px; }
#permission-error h2 { font-family: 'Syne', sans-serif; font-size: 1.2rem; font-weight: 700; }
#permission-error p { color: var(--text-dim); font-size: 13px; line-height: 1.6; max-width: 360px; }
#retry-btn {
  background: var(--accent);
  color: #000;
  border: none;
  border-radius: 8px;
  padding: 10px 24px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}
#retry-btn:hover { background: #d08820; }

/* â”€â”€â”€ SETTINGS PANEL â”€â”€â”€ */
#settings-panel {
  position: absolute;
  top: 52px; right: 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px;
  z-index: 45;
  display: none;
  flex-direction: column;
  gap: 12px;
  min-width: 200px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
}
#settings-panel.open { display: flex; }
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  font-size: 12px;
  color: var(--text-dim);
}
.setting-row label { cursor: pointer; color: var(--text); }
/* Toggle switch */
.toggle {
  position: relative;
  width: 36px; height: 20px;
  flex-shrink: 0;
}
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle-slider {
  position: absolute;
  inset: 0;
  background: var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: background 0.2s;
}
.toggle-slider::before {
  content: '';
  position: absolute;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: white;
  top: 3px; left: 3px;
  transition: transform 0.2s;
}
.toggle input:checked + .toggle-slider { background: var(--accent); }
.toggle input:checked + .toggle-slider::before { transform: translateX(16px); }

/* â”€â”€â”€ RECORDING INDICATOR â”€â”€â”€ */
#rec-indicator {
  position: absolute;
  top: 12px; left: 12px;
  display: none;
  align-items: center;
  gap: 6px;
  background: rgba(0,0,0,0.7);
  border-radius: 20px;
  padding: 4px 10px;
  font-size: 11px;
  color: var(--red);
  letter-spacing: 0.06em;
  z-index: 15;
}
#rec-indicator.show { display: flex; }
#rec-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--red);
  animation: blink 1s ease-in-out infinite;
}
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }

/* â”€â”€â”€ FPS MONITOR â”€â”€â”€ */
#fps-monitor {
  position: absolute;
  top: 12px;
  right: 12px;
  font-size: 10px;
  color: var(--text-dim);
  background: rgba(0,0,0,0.5);
  padding: 2px 6px;
  border-radius: 4px;
  z-index: 15;
  display: none;
}

/* â”€â”€â”€ ABOUT SECTION â”€â”€â”€ */
#about-toggle {
  background: none;
  border: none;
  border-top: 1px solid var(--border);
  color: var(--text-dim);
  font-family: inherit;
  font-size: 10px;
  padding: 4px;
  cursor: pointer;
  letter-spacing: 0.04em;
  transition: color 0.15s;
  text-align: center;
}
#about-toggle:hover { color: var(--text); }

#about-panel {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  background: var(--surface);
  border-top: 1px solid var(--border);
  border-radius: var(--radius) var(--radius) 0 0;
  padding: 20px;
  z-index: 35;
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  max-height: 75vh;
  overflow-y: auto;
}
#about-panel.open { transform: translateY(0); }
#about-panel h3 { font-family: 'Syne', sans-serif; font-weight: 700; margin-bottom: 10px; font-size: 1rem; }
#about-panel p, #about-panel li { font-size: 12px; line-height: 1.7; color: var(--text-dim); margin-bottom: 8px; }
#about-panel ul { padding-left: 16px; }
#about-panel strong { color: var(--text); }
#about-close {
  float: right;
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 6px;
  padding: 3px 10px;
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
}

/* â”€â”€â”€ RESPONSIVE â”€â”€â”€ */
@media (max-width: 480px) {
  :root { --film-h: 85px; }
  #logo { font-size: 1.1rem; }
  .mode-btn { padding: 6px 8px; font-size: 10px; }
  #shutter-btn { width: 52px; height: 52px; }
  #shutter-btn .shutter-inner { width: 38px; height: 38px; }
  #effects-btn span { display: none; }
}

@media (min-width: 768px) {
  #effects-grid { grid-template-columns: repeat(4, 1fr); }
  #distortion-slider-wrap { display: none !important; }
}

/* Loading spinner */
.loading {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  flex-direction: column;
  color: var(--text-dim);
  font-size: 12px;
}
.spinner {
  width: 32px; height: 32px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div id="app">
  <!-- Permission Error -->
  <div id="permission-error" role="alert" aria-live="polite">
    <div class="err-icon">ğŸ“·</div>
    <h2>Camera Access Required</h2>
    <p>SnapBooth needs access to your camera to work. Please allow camera permission in your browser settings and try again.</p>
    <button id="retry-btn" onclick="initCamera()">Allow Camera Access</button>
  </div>

  <!-- Header -->
  <header id="header">
    <div id="logo">Snap<span>Booth</span></div>
    <div id="header-right">
      <button class="icon-btn" id="fps-toggle-btn" aria-label="Toggle FPS monitor" title="FPS" onclick="toggleFPS()">â—ˆ</button>
      <button class="icon-btn" id="settings-btn" aria-label="Settings" title="Settings" onclick="toggleSettings()">âš™</button>
    </div>
  </header>

  <!-- Settings Panel -->
  <div id="settings-panel" role="dialog" aria-label="Settings">
    <div class="setting-row">
      <label for="countdown-toggle">Countdown (3s)</label>
      <label class="toggle">
        <input type="checkbox" id="countdown-toggle" checked onchange="state.countdownEnabled = this.checked">
        <span class="toggle-slider"></span>
      </label>
    </div>
    <div class="setting-row">
      <label for="flash-toggle">Flash</label>
      <label class="toggle">
        <input type="checkbox" id="flash-toggle" checked onchange="state.flashEnabled = this.checked">
        <span class="toggle-slider"></span>
      </label>
    </div>
    <div class="setting-row">
      <label for="mirror-preview">Mirror Preview</label>
      <label class="toggle">
        <input type="checkbox" id="mirror-preview" checked onchange="state.mirrorPreview = this.checked">
        <span class="toggle-slider"></span>
      </label>
    </div>
  </div>

  <!-- Main Preview Area -->
  <main id="main">
    <div class="loading" id="loading-indicator">
      <div class="spinner"></div>
      Starting cameraâ€¦
    </div>

    <div id="canvas-container" style="display:none;">
      <video id="video-source" autoplay playsinline muted aria-hidden="true"></video>
      <canvas id="preview-canvas" aria-label="Live camera preview"></canvas>

      <div id="focal-point" aria-hidden="true"></div>
      <div id="countdown-overlay" aria-hidden="true"><span id="countdown-num">3</span></div>
      <div id="flash-overlay" aria-hidden="true"></div>
      <div id="fourUp-indicator" aria-live="polite"></div>
      <div id="rec-indicator" aria-live="polite"><div id="rec-dot"></div>REC</div>
      <div id="fps-monitor" aria-hidden="true"></div>

      <!-- Distortion Slider (mobile) -->
      <div id="distortion-slider-wrap" role="group" aria-label="Effect intensity">
        <label>Intensity</label>
        <input type="range" id="distortion-amount" min="0" max="100" value="50" aria-label="Distortion amount">
      </div>
    </div>

    <!-- Effects Panel -->
    <div id="effects-panel" role="dialog" aria-label="Effects chooser">
      <div id="effects-header">
        <h2>Effects</h2>
        <button id="close-effects" onclick="closeEffects()" aria-label="Close effects panel">Done</button>
      </div>
      <div id="effects-grid" role="listbox" aria-label="Camera effects"></div>
      <div id="effects-nav">
        <button class="nav-arrow" id="prev-page" onclick="changePage(-1)" aria-label="Previous effects page">â€¹</button>
        <div id="page-dots"></div>
        <button class="nav-arrow" id="next-page" onclick="changePage(1)" aria-label="Next effects page">â€º</button>
      </div>
    </div>

    <!-- Viewer Overlay -->
    <div id="viewer-overlay" role="dialog" aria-label="Photo viewer" aria-modal="true">
      <div id="viewer-content">
        <img id="viewer-img" style="display:none;" alt="Captured photo">
        <div id="viewer-fourUp" style="display:none;"></div>
        <video id="viewer-video" style="display:none; max-width:100%; max-height:100%; border-radius:12px;" controls></video>
      </div>
      <div id="viewer-bottom">
        <button class="viewer-btn" onclick="closeViewer()" aria-label="Close viewer">âœ• Close</button>
        <button class="viewer-btn primary" id="viewer-download-btn" onclick="downloadCurrent()" aria-label="Download">â¬‡ Download</button>
        <button class="viewer-btn danger" id="viewer-delete-btn" onclick="deleteCurrent()" aria-label="Delete">âœ• Delete</button>
      </div>
    </div>
  </main>

  <!-- Bottom Bar -->
  <div id="bottom-bar">
    <div id="controls-row">
      <!-- Mode Buttons -->
      <div id="mode-group" role="group" aria-label="Capture mode">
        <button class="mode-btn active" data-mode="photo" onclick="setMode('photo')" aria-label="Single photo mode" aria-pressed="true">Photo</button>
        <button class="mode-btn" data-mode="4up" onclick="setMode('4up')" aria-label="Four up photo mode" aria-pressed="false">4-Up</button>
        <button class="mode-btn" data-mode="video" onclick="setMode('video')" aria-label="Video mode" aria-pressed="false">Video</button>
      </div>

      <!-- Shutter -->
      <button id="shutter-btn" onclick="triggerShutter()" aria-label="Take photo" role="button">
        <div class="shutter-inner"></div>
      </button>

      <!-- Effects Button -->
      <button id="effects-btn" onclick="openEffects()" aria-label="Open effects panel" aria-haspopup="true">
        âœ¦ <span>Effects</span>
      </button>
    </div>

    <div id="current-effect-name">NORMAL</div>

    <!-- Filmstrip -->
    <div id="filmstrip" role="list" aria-label="Captured photos and videos">
      <div id="filmstrip-empty">Your captures will appear here</div>
    </div>

    <button id="about-toggle" onclick="toggleAbout()" aria-label="About SnapBooth and FAQ">? About &amp; FAQ</button>
  </div>

  <!-- About Panel -->
  <div id="about-panel" role="complementary" aria-label="About SnapBooth">
    <button id="about-close" onclick="toggleAbout()">âœ•</button>
    <h3>About SnapBooth</h3>
    <p><strong>Camera Permissions:</strong> SnapBooth uses your device's camera via the browser's secure <code>getUserMedia()</code> API. Your video stream never leaves your device â€” all processing happens locally in your browser.</p>
    <p><strong>How Effects Work:</strong> Effects are applied in real-time using WebGL fragment shaders on your GPU. Each camera frame is uploaded as a texture and transformed by math in the shader.</p>
    <ul>
      <li><strong>Color effects</strong> (Sepia, B&W, Thermal, X-Ray) use color matrix transformations applied per-pixel.</li>
      <li><strong>Distortion effects</strong> (Bulge, Dent, Twirl, Fisheye, etc.) remap UV coordinates â€” instead of changing color values, they change <em>where</em> each pixel is sampled from.</li>
      <li><strong>Glow</strong> approximates bloom by blending a blurred version of the image with the original using additive blending.</li>
      <li><strong>Comic Book</strong> uses Sobel edge detection combined with posterization (color quantization).</li>
      <li><strong>Colored Pencil</strong> desaturates, amplifies edges, and simulates paper texture.</li>
      <li><strong>Pop Art</strong> tiles the frame 2Ã—2 with different color channel remappings per quadrant.</li>
    </ul>
    <p><strong>Video Recording:</strong> When recording video, SnapBooth captures the <em>processed canvas stream</em> â€” so your recorded video includes the live effect, not just raw camera footage.</p>
    <p><strong>Storage:</strong> Captures are stored in your browser's IndexedDB. Clearing site data will remove all captures.</p>
    <p><strong>Keyboard Shortcuts:</strong> Space = shutter, â† / â†’ = browse effects, Esc = close panels.</p>
  </div>
</div>

<script>
'use strict';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const state = {
  mode: 'photo',        // 'photo' | '4up' | 'video'
  effect: 0,            // index into EFFECTS array
  distortionCenter: { x: 0.5, y: 0.5 },
  distortionAmount: 0.5,
  countdownEnabled: true,
  flashEnabled: true,
  mirrorPreview: true,
  isRecording: false,
  isBusy: false,        // during countdown / 4-up sequence
  effectsPanelOpen: false,
  settingsPanelOpen: false,
  effectsPage: 0,
  galleryItems: [],     // { id, type:'photo'|'4up'|'video', data, thumb, timestamp }
  viewingIndex: -1,
  showFPS: false,
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFECTS DEFINITIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const EFFECTS = [
  { name: 'Normal',         isDistortion: false },
  { name: 'Sepia',          isDistortion: false },
  { name: 'B & W',          isDistortion: false },
  { name: 'Glow',           isDistortion: false },
  { name: 'Comic Book',     isDistortion: false },
  { name: 'Colored Pencil', isDistortion: false },
  { name: 'Thermal',        isDistortion: false },
  { name: 'X-Ray',          isDistortion: false },
  { name: 'Pop Art',        isDistortion: false },
  { name: 'Bulge',          isDistortion: true  },
  { name: 'Dent',           isDistortion: true  },
  { name: 'Twirl',          isDistortion: true  },
  { name: 'Squeeze',        isDistortion: true  },
  { name: 'Mirror',         isDistortion: false },
  { name: 'Light Tunnel',   isDistortion: true  },
  { name: 'Fisheye',        isDistortion: false },
  { name: 'Stretch',        isDistortion: true  },
];

const EFFECTS_PER_PAGE = 9; // 3Ã—3 on mobile, 4-col on desktop shows all

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WEBGL SETUP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Vertex shader â€” fullscreen quad
// u_mirror is 1.0 to flip U, 0.0 for normal
const VERT_SRC = `
attribute vec2 a_pos;
varying vec2 v_uv;
uniform float u_mirror;
void main() {
  float u = a_pos.x * 0.5 + 0.5;
  float v = 1.0 - (a_pos.y * 0.5 + 0.5);
  if (u_mirror > 0.5) { u = 1.0 - u; }
  v_uv = vec2(u, v);
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

// Fragment shader â€” all effects (GLSL ES 1.0 compatible)
// KEY RULES followed:
//  â€¢ No array indexing with loop variables (GLSL ES 1.0 restriction)
//  â€¢ blur is fully inlined â€” no arrays, no loops over non-constant indices
//  â€¢ No variable named 'dot' (reserved built-in)
//  â€¢ No 'uniform bool' â€” use float instead
//  â€¢ Guard normalize() against zero-length vectors
const FRAG_SRC = `
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_tex;
uniform vec2 u_res;
uniform float u_time;
uniform float u_amount;   // 0..1
uniform vec2 u_center;    // focal point in UV space (0..1)
uniform int u_effect;
// u_mirror is passed as float: 1.0 = mirror, 0.0 = no mirror
// (handled in vertex shader already, so this uniform is unused in frag)

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

float luma(vec3 c) {
  return dot(c, vec3(0.299, 0.587, 0.114));
}

vec3 posterize(vec3 c, float lv) {
  return floor(c * lv) / lv;
}

// HSV conversion (no arrays, pure math)
vec3 rgb2hsv(vec3 c) {
  float mx = max(c.r, max(c.g, c.b));
  float mn = min(c.r, min(c.g, c.b));
  float dif = mx - mn;
  float h = 0.0;
  if (dif > 0.0001) {
    if (mx == c.r)      h = mod((c.g - c.b) / dif, 6.0) / 6.0;
    else if (mx == c.g) h = ((c.b - c.r) / dif + 2.0) / 6.0;
    else                h = ((c.r - c.g) / dif + 4.0) / 6.0;
  }
  float s = (mx < 0.0001) ? 0.0 : dif / mx;
  return vec3(h, s, mx);
}

vec3 hsv2rgb(vec3 c) {
  float h = c.x * 6.0;
  float s = c.y;
  float v = c.z;
  float i = floor(h);
  float f = h - i;
  float p = v * (1.0 - s);
  float q = v * (1.0 - f * s);
  float t2 = v * (1.0 - (1.0 - f) * s);
  if (i < 1.0) return vec3(v, t2, p);
  if (i < 2.0) return vec3(q, v, p);
  if (i < 3.0) return vec3(p, v, t2);
  if (i < 4.0) return vec3(p, q, v);
  if (i < 5.0) return vec3(t2, p, v);
  return vec3(v, p, q);
}

// Thermal gradient: cold (black/blue) -> hot (white)
vec3 thermalGrad(float t) {
  t = clamp(t, 0.0, 1.0);
  vec3 col = vec3(0.0);
  col = mix(col,  vec3(0.0, 0.0, 1.0), smoothstep(0.0,  0.2,  t));
  col = mix(col,  vec3(0.0, 1.0, 1.0), smoothstep(0.2,  0.4,  t));
  col = mix(col,  vec3(0.0, 1.0, 0.0), smoothstep(0.4,  0.6,  t));
  col = mix(col,  vec3(1.0, 1.0, 0.0), smoothstep(0.6,  0.8,  t));
  col = mix(col,  vec3(1.0, 0.0, 0.0), smoothstep(0.8,  0.9,  t));
  col = mix(col,  vec3(1.0, 1.0, 1.0), smoothstep(0.9,  1.0,  t));
  return col;
}

// Sobel edge detection (fully inlined, no arrays)
float sobel(vec2 uv, vec2 px) {
  float tl = luma(texture2D(u_tex, uv + vec2(-px.x,  px.y)).rgb);
  float tc = luma(texture2D(u_tex, uv + vec2( 0.0,   px.y)).rgb);
  float tr = luma(texture2D(u_tex, uv + vec2( px.x,  px.y)).rgb);
  float ml = luma(texture2D(u_tex, uv + vec2(-px.x,  0.0 )).rgb);
  float mr = luma(texture2D(u_tex, uv + vec2( px.x,  0.0 )).rgb);
  float bl = luma(texture2D(u_tex, uv + vec2(-px.x, -px.y)).rgb);
  float bc = luma(texture2D(u_tex, uv + vec2( 0.0,  -px.y)).rgb);
  float br = luma(texture2D(u_tex, uv + vec2( px.x, -px.y)).rgb);
  float gx = -tl - 2.0*ml - bl + tr + 2.0*mr + br;
  float gy = -tl - 2.0*tc - tr + bl + 2.0*bc + br;
  return clamp(sqrt(gx*gx + gy*gy), 0.0, 1.0);
}

// Fully inlined 9-tap gaussian blur â€” no arrays, no loop variable indexing.
// Each tap is a separate texture fetch with a compile-time-constant offset.
vec4 blur9(vec2 uv, vec2 px) {
  vec4 s = vec4(0.0);
  // 3x3 kernel weights: corners=0.0625, edges=0.125, center=0.25
  s += texture2D(u_tex, uv + vec2(-px.x,  px.y)) * 0.0625;
  s += texture2D(u_tex, uv + vec2( 0.0,   px.y)) * 0.1250;
  s += texture2D(u_tex, uv + vec2( px.x,  px.y)) * 0.0625;
  s += texture2D(u_tex, uv + vec2(-px.x,  0.0 )) * 0.1250;
  s += texture2D(u_tex, uv + vec2( 0.0,   0.0 )) * 0.2500;
  s += texture2D(u_tex, uv + vec2( px.x,  0.0 )) * 0.1250;
  s += texture2D(u_tex, uv + vec2(-px.x, -px.y)) * 0.0625;
  s += texture2D(u_tex, uv + vec2( 0.0,  -px.y)) * 0.1250;
  s += texture2D(u_tex, uv + vec2( px.x, -px.y)) * 0.0625;
  return s;
}

// Multi-radius blur for glow: call blur9 with different px scales
vec4 blurR(vec2 uv, vec2 px, float r) { return blur9(uv, px * r); }

// Hash noise for paper texture
float nHash(vec2 p) {
  vec2 q = fract(p * vec2(127.1, 311.7));
  q += dot(q, q + 19.19);
  return fract(q.x * q.y);
}

// Safe normalize: returns zero vector if length is near zero
vec2 safeNorm(vec2 v) {
  float len = length(v);
  return (len > 0.0001) ? v / len : vec2(0.0);
}

void main() {
  vec2 uv     = v_uv;
  vec2 px     = 1.0 / u_res;
  float amt   = u_amount;          // 0..1
  vec2 ctr    = u_center;          // focal point
  vec2 dv     = uv - ctr;          // vector from focal to pixel
  float dlen  = length(dv);
  vec2 duv    = uv;                 // distorted UV (used by distortion effects)

  // â”€â”€ 0: Normal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (u_effect == 0) {
    gl_FragColor = texture2D(u_tex, uv);
    return;
  }

  // â”€â”€ 1: Sepia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (u_effect == 1) {
    float l = luma(texture2D(u_tex, uv).rgb);
    gl_FragColor = vec4(clamp(vec3(l*1.2, l*1.0, l*0.72), 0.0, 1.0), 1.0);
    return;
  }

  // â”€â”€ 2: B & W â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (u_effect == 2) {
    float l = luma(texture2D(u_tex, uv).rgb);
    l = clamp((l - 0.5) * 1.25 + 0.5, 0.0, 1.0); // contrast boost
    gl_FragColor = vec4(vec3(l), 1.0);
    return;
  }

  // â”€â”€ 3: Glow (bloom) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Approximate bloom: blend original with wide blurs additively on brights
  if (u_effect == 3) {
    vec4 orig = texture2D(u_tex, uv);
    vec4 b1   = blurR(uv, px, 2.0);
    vec4 b2   = blurR(uv, px, 5.0);
    vec4 b3   = blurR(uv, px, 10.0);
    vec4 bloom = (b1 + b2 * 0.7 + b3 * 0.4) / 2.1;
    float bright = max(bloom.r, max(bloom.g, bloom.b));
    vec4 result  = orig + bloom * smoothstep(0.3, 0.8, bright) * amt * 1.8;
    gl_FragColor = vec4(clamp(result.rgb, 0.0, 1.0), 1.0);
    return;
  }

  // â”€â”€ 4: Comic Book â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Posterize + Sobel outlines + halftone shadows
  if (u_effect == 4) {
    vec3 c = posterize(texture2D(u_tex, uv).rgb, 4.0);
    float edge    = sobel(uv, px * 1.5);
    float outline = step(0.35, edge);
    // Halftone: dot pattern in shadowed areas
    // avoid naming variable 'dot' (GLSL built-in)
    float ld      = luma(c);
    vec2 hUV      = uv * u_res / 6.0;
    float dotMask = step(length(fract(hUV) - 0.5), 0.28 * (1.0 - ld));
    c = mix(c, c * 0.82, dotMask * 0.4);
    c = mix(c, vec3(0.0), outline);
    // Saturation boost
    vec3 hsv = rgb2hsv(c);
    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);
    gl_FragColor = vec4(clamp(hsv2rgb(hsv), 0.0, 1.0), 1.0);
    return;
  }

  // â”€â”€ 5: Colored Pencil â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Desaturated + edge-as-pencil-lines on warm paper background
  if (u_effect == 5) {
    vec3 c  = texture2D(u_tex, uv).rgb;
    float l = luma(c);
    c = mix(vec3(l), c, 0.2);
    vec3 paper  = vec3(0.97, 0.94, 0.87);
    float edge  = sobel(uv, px * 1.2);
    float pencil = 1.0 - clamp(edge * 3.5, 0.0, 1.0);
    float grain  = nHash(uv * u_res * 0.5) * 0.05;
    vec3 result  = paper * pencil + grain;
    result = mix(result, c * 0.7 + result * 0.3, 0.25);
    gl_FragColor = vec4(clamp(result, 0.0, 1.0), 1.0);
    return;
  }

  // â”€â”€ 6: Thermal Camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Map luminance to thermal heat palette (blue=cold, red/white=hot)
  if (u_effect == 6) {
    vec4 blurred = blurR(uv, px, 1.5);
    float heat   = luma(blurred.rgb);
    gl_FragColor = vec4(thermalGrad(heat), 1.0);
    return;
  }

  // â”€â”€ 7: X-Ray â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Inverted high-contrast with cool blue tint
  if (u_effect == 7) {
    float l = luma(texture2D(u_tex, uv).rgb);
    l = 1.0 - l;                                        // invert
    l = clamp((l - 0.5) * 2.2 + 0.5, 0.0, 1.0);       // contrast
    vec3 xray = mix(vec3(0.0, 0.0, 0.12), vec3(0.85, 0.95, 1.0), l);
    gl_FragColor = vec4(xray, 1.0);
    return;
  }

  // â”€â”€ 8: Pop Art (Warhol 2Ã—2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Four tiles each with a different bold colour remap + halftone
  if (u_effect == 8) {
    vec2 tileUV = fract(uv * 2.0);
    float tx    = step(0.5, uv.x);    // 0 = left col, 1 = right col
    float ty    = step(0.5, uv.y);    // 0 = top row,  1 = bottom row
    vec3 c      = posterize(texture2D(u_tex, tileUV).rgb, 3.0);
    float ld    = luma(c);
    vec3 result;
    // Use mix() chains instead of int comparisons (safer on all drivers)
    // Q0 top-left: warm orange
    vec3 q0 = vec3(c.r*1.3, c.g*0.7, c.b*0.3);
    // Q1 top-right: cool blue-purple
    vec3 q1 = vec3(c.b*0.5, c.r*0.5, c.g*1.5);
    // Q2 bottom-left: green-yellow
    vec3 q2 = vec3(c.g*1.2, c.r*1.1, c.b*0.2);
    // Q3 bottom-right: hot pink-magenta
    vec3 q3 = vec3(c.r*1.4, c.b*0.4, c.g*1.1);
    // Blend by tile position
    result = mix(mix(q0, q1, tx), mix(q2, q3, tx), ty);
    // Halftone dots in shadows
    vec2 htUV    = tileUV * u_res * 0.5 / 4.0;
    float htMask = step(length(fract(htUV) - 0.5), 0.27 * (1.0 - ld));
    result = mix(result, result * 0.55, htMask * 0.5);
    gl_FragColor = vec4(clamp(result, 0.0, 1.0), 1.0);
    return;
  }

  // â”€â”€ 9: Bulge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Radial barrel warp â€” pixels pushed outward from centre.
  // r_new = r ^ exponent; exponent < 1 â†’ bulge outward
  if (u_effect == 9) {
    float radius   = 0.5;
    float normDist = dlen / radius;
    if (normDist < 1.0 && dlen > 0.0001) {
      float expo  = 0.3 + (1.0 - amt) * 0.8; // 0.3..1.1; lower = more bulge
      float rNew  = pow(normDist, expo) * radius;
      duv = ctr + safeNorm(dv) * rNew;
    }
    gl_FragColor = texture2D(u_tex, clamp(duv, 0.0, 1.0));
    return;
  }

  // â”€â”€ 10: Dent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Opposite of bulge â€” pixels pulled inward (pinch).
  if (u_effect == 10) {
    float radius   = 0.5;
    float normDist = dlen / radius;
    if (normDist < 1.0 && dlen > 0.0001) {
      float expo  = 1.2 + amt * 2.0; // >1 â†’ pinch inward
      float rNew  = pow(normDist, expo) * radius;
      duv = ctr + safeNorm(dv) * rNew;
    }
    gl_FragColor = texture2D(u_tex, clamp(duv, 0.0, 1.0));
    return;
  }

  // â”€â”€ 11: Twirl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Rotate pixels around focal point; rotation angle decays with distance.
  if (u_effect == 11) {
    float radius    = 0.45;
    float normDist  = dlen / radius;
    float maxAngle  = (amt - 0.5) * 6.2832; // -Ï€..Ï€ full twirl range
    float tAngle    = maxAngle * max(0.0, 1.0 - normDist);
    float ca = cos(tAngle);
    float sa = sin(tAngle);
    duv = ctr + vec2(dv.x*ca - dv.y*sa, dv.x*sa + dv.y*ca);
    gl_FragColor = texture2D(u_tex, clamp(duv, 0.0, 1.0));
    return;
  }

  // â”€â”€ 12: Squeeze â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Compress both axes toward centre within a radius; creates pinch/squeeze.
  if (u_effect == 12) {
    float radius   = 0.5;
    float normDist = dlen / radius;
    float sq       = (1.0 - smoothstep(0.0, 1.0, normDist)) * amt * 1.6;
    duv = ctr + dv * (1.0 - sq);
    gl_FragColor = texture2D(u_tex, clamp(duv, 0.0, 1.0));
    return;
  }

  // â”€â”€ 13: Mirror â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // amt < 0.5 â†’ simple horizontal flip; amt >= 0.5 â†’ split-mirror symmetry
  if (u_effect == 13) {
    vec2 muv = uv;
    if (amt >= 0.5) {
      // Split mirror: fold left half onto right and vice-versa
      muv.x = 1.0 - abs(uv.x * 2.0 - 1.0); // maps [0..1] to [0..1..0]
    } else {
      muv.x = 1.0 - uv.x;
    }
    gl_FragColor = texture2D(u_tex, clamp(muv, 0.0, 1.0));
    return;
  }

  // â”€â”€ 14: Light Tunnel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Radial zoom-blur toward focal point; 8 inlined samples (no loop array).
  // Each sample is pulled progressively closer to centre.
  if (u_effect == 14) {
    float pull = amt * 0.55;
    // 8 samples, all inlined as constant-index taps:
    vec4 acc = vec4(0.0);
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.125));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.250));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.375));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.500));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.625));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.750));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 0.875));
    acc += texture2D(u_tex, mix(uv, ctr, pull * 1.000));
    acc /= 8.0;
    // Vignette to darken edges
    float vigR = length(uv - 0.5);
    float vig  = 1.0 - smoothstep(0.25, 0.65, vigR * (1.0 + amt * 0.8));
    gl_FragColor = vec4(acc.rgb * vig, 1.0);
    return;
  }

  // â”€â”€ 15: Fisheye â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Barrel distortion: r_new = r * (1 + k*rÂ²), applied globally.
  if (u_effect == 15) {
    vec2 cv  = (uv - 0.5) * 2.0;     // centred â€“1..1
    float r2 = dot(cv, cv);
    float k  = amt * 0.85;
    vec2 dw  = cv * (1.0 + k * r2);  // barrel-distorted
    duv = dw * 0.5 + 0.5;
    if (duv.x < 0.0 || duv.x > 1.0 || duv.y < 0.0 || duv.y > 1.0) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
      gl_FragColor = texture2D(u_tex, duv);
    }
    return;
  }

  // â”€â”€ 16: Stretch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Directional horizontal stretch around focal point.
  if (u_effect == 16) {
    float radius    = 0.5;
    float normDist  = dlen / radius;
    float influence = max(0.0, 1.0 - normDist);
    float strX      = 1.0 + (amt - 0.5) * 2.5 * influence;
    float strY      = 1.0 - (amt - 0.5) * 1.0 * influence;
    duv = ctr + vec2(dv.x / max(0.05, strX), dv.y * strY);
    gl_FragColor = texture2D(u_tex, clamp(duv, 0.0, 1.0));
    return;
  }

  // Fallback â€” should never reach here
  gl_FragColor = texture2D(u_tex, uv);
}
`;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WEBGL RENDERER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let gl, program, uniforms, quadBuffer, texture;
const canvas = document.getElementById('preview-canvas');
const video = document.getElementById('video-source');

function compileShaderWithLog(gl, type, src) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    const info = gl.getShaderInfoLog(sh);
    console.error('Shader compile error:', info);
    // Show first error line in UI so it's visible
    const errDiv = document.createElement('div');
    errDiv.style.cssText = 'position:fixed;bottom:0;left:0;right:0;background:red;color:white;padding:8px;font:12px monospace;z-index:9999;white-space:pre-wrap;max-height:150px;overflow:auto;';
    errDiv.textContent = 'GLSL Error: ' + info;
    document.body.appendChild(errDiv);
    gl.deleteShader(sh);
    return null;
  }
  return sh;
}

function initGL() {
  gl = canvas.getContext('webgl', { preserveDrawingBuffer: true, antialias: false });
  if (!gl) { 
    showPermError('WebGL not supported in this browser. Please try Chrome or Firefox.');
    return false; 
  }

  const vert = compileShaderWithLog(gl, gl.VERTEX_SHADER, VERT_SRC);
  const frag = compileShaderWithLog(gl, gl.FRAGMENT_SHADER, FRAG_SRC);
  if (!vert || !frag) return false;

  program = gl.createProgram();
  gl.attachShader(program, vert);
  gl.attachShader(program, frag);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return false;
  }
  gl.useProgram(program);

  // Fullscreen quad
  quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

  const a_pos = gl.getAttribLocation(program, 'a_pos');
  gl.enableVertexAttribArray(a_pos);
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  // Uniforms
  uniforms = {
    tex:    gl.getUniformLocation(program, 'u_tex'),
    res:    gl.getUniformLocation(program, 'u_res'),
    time:   gl.getUniformLocation(program, 'u_time'),
    amount: gl.getUniformLocation(program, 'u_amount'),
    center: gl.getUniformLocation(program, 'u_center'),
    effect: gl.getUniformLocation(program, 'u_effect'),
    mirror: gl.getUniformLocation(program, 'u_mirror'),
  };

  // Video texture
  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.uniform1i(uniforms.tex, 0);

  return true;
}

function renderFrame(effectIndex, amount, center, mirror) {
  if (!gl || !video || video.readyState < 2) return;

  // Upload video frame to texture
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

  // Set uniforms
  gl.uniform2f(uniforms.res, canvas.width, canvas.height);
  gl.uniform1f(uniforms.time, performance.now() * 0.001);
  gl.uniform1f(uniforms.amount, amount);
  gl.uniform2f(uniforms.center, center.x, center.y);
  gl.uniform1i(uniforms.effect, effectIndex);
  gl.uniform1f(uniforms.mirror, mirror ? 1.0 : 0.0);  // float, not bool

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFECT TILE RENDERER (for effects panel)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Use a small secondary WebGL canvas to render tiles
let tileGL, tileProgram, tileUniforms, tileBuffer, tileTexture;
let tileCanvas;

function initTileGL() {
  tileCanvas = document.createElement('canvas');
  tileCanvas.width = 160; tileCanvas.height = 120;
  tileGL = tileCanvas.getContext('webgl', { preserveDrawingBuffer: true });
  if (!tileGL) return false;

  function compileShader(type, src) {
    const sh = tileGL.createShader(type);
    tileGL.shaderSource(sh, src);
    tileGL.compileShader(sh);
    if (!tileGL.getShaderParameter(sh, tileGL.COMPILE_STATUS)) {
      console.error('Tile shader error:', tileGL.getShaderInfoLog(sh));
      return null;
    }
    return sh;
  }

  const v = compileShader(tileGL.VERTEX_SHADER, VERT_SRC);
  const f = compileShader(tileGL.FRAGMENT_SHADER, FRAG_SRC);
  if (!v || !f) return false;

  tileProgram = tileGL.createProgram();
  tileGL.attachShader(tileProgram, v);
  tileGL.attachShader(tileProgram, f);
  tileGL.linkProgram(tileProgram);
  if (!tileGL.getProgramParameter(tileProgram, tileGL.LINK_STATUS)) {
    console.error('Tile program error:', tileGL.getProgramInfoLog(tileProgram));
    return false;
  }
  tileGL.useProgram(tileProgram);

  tileBuffer = tileGL.createBuffer();
  tileGL.bindBuffer(tileGL.ARRAY_BUFFER, tileBuffer);
  tileGL.bufferData(tileGL.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), tileGL.STATIC_DRAW);
  const a = tileGL.getAttribLocation(tileProgram, 'a_pos');
  tileGL.enableVertexAttribArray(a);
  tileGL.vertexAttribPointer(a, 2, tileGL.FLOAT, false, 0, 0);

  tileUniforms = {
    tex:    tileGL.getUniformLocation(tileProgram, 'u_tex'),
    res:    tileGL.getUniformLocation(tileProgram, 'u_res'),
    time:   tileGL.getUniformLocation(tileProgram, 'u_time'),
    amount: tileGL.getUniformLocation(tileProgram, 'u_amount'),
    center: tileGL.getUniformLocation(tileProgram, 'u_center'),
    effect: tileGL.getUniformLocation(tileProgram, 'u_effect'),
    mirror: tileGL.getUniformLocation(tileProgram, 'u_mirror'),
  };

  tileTexture = tileGL.createTexture();
  tileGL.bindTexture(tileGL.TEXTURE_2D, tileTexture);
  tileGL.texParameteri(tileGL.TEXTURE_2D, tileGL.TEXTURE_WRAP_S, tileGL.CLAMP_TO_EDGE);
  tileGL.texParameteri(tileGL.TEXTURE_2D, tileGL.TEXTURE_WRAP_T, tileGL.CLAMP_TO_EDGE);
  tileGL.texParameteri(tileGL.TEXTURE_2D, tileGL.TEXTURE_MIN_FILTER, tileGL.LINEAR);
  tileGL.texParameteri(tileGL.TEXTURE_2D, tileGL.TEXTURE_MAG_FILTER, tileGL.LINEAR);
  tileGL.uniform1i(tileUniforms.tex, 0);

  return true;
}

let tileUpdateIndex = 0;
let tileDOMs = []; // canvas elements per tile

function updateEffectTiles() {
  if (!state.effectsPanelOpen || !tileGL || !video || video.readyState < 2) return;

  // Update one tile per call (cycle through all)
  const pageStart = state.effectsPage * EFFECTS_PER_PAGE;
  const count = Math.min(EFFECTS_PER_PAGE, EFFECTS.length - pageStart);
  
  if (count <= 0) return;
  
  const tileIndex = tileUpdateIndex % count;
  const effectIndex = pageStart + tileIndex;
  const tileCanvas2D = tileDOMs[tileIndex];
  if (!tileCanvas2D) { tileUpdateIndex++; return; }
  
  // Render this effect to tileCanvas
  tileGL.bindTexture(tileGL.TEXTURE_2D, tileTexture);
  tileGL.texImage2D(tileGL.TEXTURE_2D, 0, tileGL.RGBA, tileGL.RGBA, tileGL.UNSIGNED_BYTE, video);
  tileGL.uniform2f(tileUniforms.res, tileCanvas.width, tileCanvas.height);
  tileGL.uniform1f(tileUniforms.time, performance.now() * 0.001);
  tileGL.uniform1f(tileUniforms.amount, 0.65); // demo amount for tiles
  tileGL.uniform2f(tileUniforms.center, 0.5, 0.5);
  tileGL.uniform1i(tileUniforms.effect, effectIndex);
  tileGL.uniform1f(tileUniforms.mirror, 0.0);  // no mirror in tiles
  tileGL.viewport(0, 0, tileCanvas.width, tileCanvas.height);
  tileGL.drawArrays(tileGL.TRIANGLE_STRIP, 0, 4);

  // Copy to tile's 2D canvas
  const ctx = tileCanvas2D.getContext('2d');
  ctx.drawImage(tileCanvas, 0, 0, tileCanvas2D.width, tileCanvas2D.height);

  tileUpdateIndex++;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAMERA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let stream = null;
let mediaRecorder = null;
let recordedChunks = [];

function showPermError(msg) {
  document.getElementById('loading-indicator').style.display = 'none';
  const pe = document.getElementById('permission-error');
  pe.classList.add('show');
  if (msg) pe.querySelector('p').textContent = msg;
}

async function initCamera() {
  document.getElementById('permission-error').classList.remove('show');
  document.getElementById('loading-indicator').style.display = 'flex';

  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: true,
    });

    video.srcObject = stream;
    await new Promise(r => video.addEventListener('loadedmetadata', r, { once: true }));
    await video.play();

    // Size canvas to video aspect ratio
    const vw = video.videoWidth || 1280;
    const vh = video.videoHeight || 720;
    const aspect = vw / vh;

    // Determine target resolution (lower on mobile)
    const isMobile = window.innerWidth < 600;
    const targetW = isMobile ? 640 : 1280;
    canvas.width = targetW;
    canvas.height = Math.round(targetW / aspect);

    if (!initGL()) return;
    initTileGL();

    document.getElementById('loading-indicator').style.display = 'none';
    document.getElementById('canvas-container').style.display = 'flex';

    startLoop();
  } catch (err) {
    console.error('Camera error:', err);
    let msg = 'SnapBooth needs camera access to work. Click "Allow Camera Access" and make sure no other app is using your camera.';
    if (err.name === 'NotAllowedError') msg = 'Camera permission was denied. Click the camera icon in your browser address bar to allow access, then click "Allow Camera Access" below.';
    else if (err.name === 'NotFoundError') msg = 'No camera found on this device.';
    else if (err.name === 'NotReadableError') msg = 'Your camera is already in use by another application.';
    showPermError(msg);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDER LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = 0;
let frameCount = 0;
let fpsDisplay = 0;
let loopId = null;

function startLoop() {
  if (loopId) cancelAnimationFrame(loopId);
  loop(0);
}

function loop(ts) {
  loopId = requestAnimationFrame(loop);

  const dt = ts - lastTime;
  lastTime = ts;

  // FPS
  frameCount++;
  if (frameCount % 30 === 0) {
    fpsDisplay = Math.round(1000 / dt);
    if (state.showFPS) {
      document.getElementById('fps-monitor').textContent = `${fpsDisplay} fps`;
    }
  }

  // Main render
  renderFrame(
    state.effect,
    state.distortionAmount,
    state.distortionCenter,
    state.mirrorPreview
  );

  // Effect tiles (one per frame, cycling)
  updateEffectTiles();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAPTURE: PHOTO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function capturePhoto() {
  if (state.isBusy) return;
  state.isBusy = true;

  if (state.countdownEnabled) await countdown();
  triggerFlash();

  const dataURL = canvas.toDataURL('image/jpeg', 0.92);
  const thumb = await makeThumbnail(dataURL);
  const item = {
    id: Date.now(),
    type: 'photo',
    data: dataURL,
    thumb,
    timestamp: Date.now(),
    effect: EFFECTS[state.effect].name,
  };
  addToGallery(item);

  state.isBusy = false;
}

async function captureFourUp() {
  if (state.isBusy) return;
  state.isBusy = true;

  const images = [];
  const indicator = document.getElementById('fourUp-indicator');
  indicator.classList.add('show');

  for (let i = 0; i < 4; i++) {
    indicator.textContent = `Shot ${i + 1} of 4`;
    if (state.countdownEnabled) await countdown();
    triggerFlash();

    images.push(canvas.toDataURL('image/jpeg', 0.92));

    if (i < 3) {
      await sleep(600);
    }
  }

  indicator.classList.remove('show');

  // Composite 2Ã—2
  const composite = await make4UpComposite(images);
  const thumb = await makeThumbnail(composite);
  const item = {
    id: Date.now(),
    type: '4up',
    data: composite,
    images,
    thumb,
    timestamp: Date.now(),
    effect: EFFECTS[state.effect].name,
  };
  addToGallery(item);
  state.isBusy = false;
}

async function make4UpComposite(images) {
  const W = canvas.width * 2 + 4;
  const H = canvas.height * 2 + 4;
  const offscreen = Object.assign(document.createElement('canvas'), { width: W, height: H });
  const ctx = offscreen.getContext('2d');
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  for (let i = 0; i < 4; i++) {
    const img = await loadImg(images[i]);
    const col = i % 2, row = Math.floor(i / 2);
    ctx.drawImage(img, col * (canvas.width + 2), row * (canvas.height + 2), canvas.width, canvas.height);
  }
  return offscreen.toDataURL('image/jpeg', 0.92);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAPTURE: VIDEO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRecording() {
  recordedChunks = [];

  // Capture processed canvas stream
  const canvasStream = canvas.captureStream(30);

  // Add audio from original stream
  const audioTracks = stream ? stream.getAudioTracks() : [];
  audioTracks.forEach(t => canvasStream.addTrack(t));

  // Pick supported codec
  const mimeTypes = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4'];
  const mime = mimeTypes.find(m => MediaRecorder.isTypeSupported(m)) || '';
  mediaRecorder = new MediaRecorder(canvasStream, mime ? { mimeType: mime } : {});

  mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
  mediaRecorder.onstop = saveRecording;
  mediaRecorder.start(100);

  state.isRecording = true;
  document.getElementById('shutter-btn').classList.add('recording');
  document.getElementById('shutter-btn').setAttribute('aria-label', 'Stop recording');
  document.getElementById('rec-indicator').classList.add('show');
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  state.isRecording = false;
  document.getElementById('shutter-btn').classList.remove('recording');
  document.getElementById('shutter-btn').setAttribute('aria-label', 'Start recording');
  document.getElementById('rec-indicator').classList.remove('show');
}

function saveRecording() {
  const blob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });
  const url = URL.createObjectURL(blob);
  const thumb = 'ğŸ¬'; // video thumbnail placeholder

  // Generate video thumbnail
  const thumbVideo = document.createElement('video');
  thumbVideo.src = url;
  thumbVideo.muted = true;
  thumbVideo.currentTime = 0.5;

  thumbVideo.addEventListener('seeked', () => {
    const tc = document.createElement('canvas');
    tc.width = 160; tc.height = 120;
    tc.getContext('2d').drawImage(thumbVideo, 0, 0, 160, 120);
    const thumbURL = tc.toDataURL('image/jpeg', 0.7);

    const item = {
      id: Date.now(),
      type: 'video',
      data: url,
      blob,
      thumb: thumbURL,
      timestamp: Date.now(),
      effect: EFFECTS[state.effect].name,
    };
    addToGallery(item);
  }, { once: true });

  thumbVideo.load();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COUNTDOWN + FLASH
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function countdown() {
  const overlay = document.getElementById('countdown-overlay');
  const num = document.getElementById('countdown-num');

  for (let i = 3; i >= 1; i--) {
    num.textContent = i;
    overlay.classList.remove('show');
    void overlay.offsetWidth; // force reflow
    overlay.classList.add('show');
    await sleep(900);
  }
  overlay.classList.remove('show');
  await sleep(100);
}

function triggerFlash() {
  if (!state.flashEnabled) return;
  const f = document.getElementById('flash-overlay');
  f.classList.remove('flash');
  void f.offsetWidth;
  f.classList.add('flash');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GALLERY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DB_NAME = 'snapbooth';
const DB_VERSION = 1;
let db = null;

function openDB() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('items')) {
        d.createObjectStore('items', { keyPath: 'id' });
      }
    };
    req.onsuccess = e => { db = e.target.result; res(db); };
    req.onerror = () => rej(req.error);
  });
}

async function saveItemToDB(item) {
  if (!db) return;
  const dbItem = { ...item };
  if (dbItem.blob) delete dbItem.blob; // blobs are stored via URL already
  try {
    const tx = db.transaction('items', 'readwrite');
    tx.objectStore('items').put(dbItem);
  } catch (e) { console.warn('DB save failed', e); }
}

async function loadFromDB() {
  if (!db) return;
  try {
    const tx = db.transaction('items', 'readonly');
    const req = tx.objectStore('items').getAll();
    req.onsuccess = () => {
      const items = req.result || [];
      items.sort((a, b) => a.timestamp - b.timestamp);
      items.forEach(item => addToGallery(item, false));
    };
  } catch (e) { console.warn('DB load failed', e); }
}

async function deleteItemFromDB(id) {
  if (!db) return;
  try {
    const tx = db.transaction('items', 'readwrite');
    tx.objectStore('items').delete(id);
  } catch (e) {}
}

function addToGallery(item, save = true) {
  state.galleryItems.push(item);
  renderFilmItem(item, true);
  if (save) saveItemToDB(item);
}

function renderFilmItem(item, animate = false) {
  const strip = document.getElementById('filmstrip');
  const empty = document.getElementById('filmstrip-empty');
  if (empty) empty.style.display = 'none';

  const el = document.createElement('div');
  el.className = 'film-item' + (animate ? ' film-item-new' : '');
  el.setAttribute('role', 'listitem');
  el.setAttribute('tabindex', '0');
  el.setAttribute('aria-label', `${item.type} captured with ${item.effect} effect`);
  el.dataset.id = item.id;

  if (item.type === 'video') {
    const img = document.createElement('img');
    img.src = item.thumb;
    img.alt = 'Video thumbnail';
    el.appendChild(img);
    const badge = document.createElement('div');
    badge.className = 'film-item-badge';
    badge.textContent = 'â–¶ VID';
    el.appendChild(badge);
  } else {
    const img = document.createElement('img');
    img.src = item.thumb;
    img.alt = item.type === '4up' ? 'Four-up photo' : 'Photo';
    el.appendChild(img);
    if (item.type === '4up') {
      const badge = document.createElement('div');
      badge.className = 'film-item-badge';
      badge.textContent = '4Ã—';
      el.appendChild(badge);
    }
  }

  el.onclick = () => openViewer(item.id);
  el.onkeydown = e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openViewer(item.id); } };

  strip.appendChild(el);
  strip.scrollLeft = strip.scrollWidth;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VIEWER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openViewer(id) {
  const item = state.galleryItems.find(i => i.id === id);
  if (!item) return;

  state.viewingIndex = state.galleryItems.indexOf(item);
  const overlay = document.getElementById('viewer-overlay');
  const img = document.getElementById('viewer-img');
  const fourUp = document.getElementById('viewer-fourUp');
  const vid = document.getElementById('viewer-video');

  img.style.display = 'none';
  fourUp.style.display = 'none';
  vid.style.display = 'none';
  fourUp.innerHTML = '';

  if (item.type === 'photo') {
    img.src = item.data;
    img.style.display = 'block';
  } else if (item.type === '4up') {
    fourUp.style.display = 'grid';
    (item.images || [item.data]).forEach((src, i) => {
      const subImg = document.createElement('img');
      subImg.src = src;
      subImg.alt = `Shot ${i + 1}`;
      subImg.onclick = e => {
        e.stopPropagation();
        // Zoom in: show as full image
        img.src = src;
        img.style.display = 'block';
        fourUp.style.display = 'none';
      };
      fourUp.appendChild(subImg);
    });
  } else if (item.type === 'video') {
    vid.src = item.data;
    vid.style.display = 'block';
  }

  overlay.classList.add('open');
  document.getElementById('viewer-download-btn').dataset.id = id;
  document.getElementById('viewer-delete-btn').dataset.id = id;
}

function closeViewer() {
  const overlay = document.getElementById('viewer-overlay');
  overlay.classList.remove('open');
  const vid = document.getElementById('viewer-video');
  vid.pause();
  vid.src = '';
  state.viewingIndex = -1;
}

function downloadCurrent() {
  const item = state.galleryItems[state.viewingIndex];
  if (!item) return;

  const a = document.createElement('a');
  a.href = item.data;
  const ext = item.type === 'video' ? 'webm' : 'jpg';
  a.download = `snapbooth_${item.type}_${item.id}.${ext}`;
  a.click();
}

function deleteCurrent() {
  const item = state.galleryItems[state.viewingIndex];
  if (!item) return;

  // Remove from state
  state.galleryItems.splice(state.viewingIndex, 1);

  // Remove from DOM
  const el = document.querySelector(`.film-item[data-id="${item.id}"]`);
  if (el) el.remove();

  // Delete from DB
  deleteItemFromDB(item.id);

  // Show empty message if needed
  if (state.galleryItems.length === 0) {
    const empty = document.getElementById('filmstrip-empty');
    if (empty) empty.style.display = 'flex';
  }

  closeViewer();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFECTS PANEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PAGES = Math.ceil(EFFECTS.length / EFFECTS_PER_PAGE);

function buildEffectsGrid() {
  const grid = document.getElementById('effects-grid');
  grid.innerHTML = '';
  tileDOMs = [];

  const pageStart = state.effectsPage * EFFECTS_PER_PAGE;
  const count = Math.min(EFFECTS_PER_PAGE, EFFECTS.length - pageStart);

  for (let i = 0; i < count; i++) {
    const effectIndex = pageStart + i;
    const eff = EFFECTS[effectIndex];

    const tile = document.createElement('div');
    tile.className = 'effect-tile' + (effectIndex === state.effect ? ' selected' : '');
    tile.setAttribute('role', 'option');
    tile.setAttribute('aria-selected', effectIndex === state.effect ? 'true' : 'false');
    tile.setAttribute('aria-label', eff.name);
    tile.setAttribute('tabindex', '0');
    tile.dataset.effect = effectIndex;

    const c = document.createElement('canvas');
    c.width = 160; c.height = 120;
    tile.appendChild(c);
    tileDOMs.push(c);

    const label = document.createElement('div');
    label.className = 'effect-tile-label';
    label.textContent = eff.name;
    tile.appendChild(label);

    tile.onclick = () => selectEffect(effectIndex);
    tile.onkeydown = e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); selectEffect(effectIndex); } };

    grid.appendChild(tile);
  }

  buildPageDots();
  tileUpdateIndex = 0;
}

function buildPageDots() {
  const dotsEl = document.getElementById('page-dots');
  dotsEl.innerHTML = '';
  for (let i = 0; i < PAGES; i++) {
    const dot = document.createElement('div');
    dot.className = 'page-dot' + (i === state.effectsPage ? ' active' : '');
    dot.onclick = () => goToPage(i);
    dot.setAttribute('aria-label', `Effects page ${i + 1}`);
    dotsEl.appendChild(dot);
  }
  document.getElementById('prev-page').disabled = state.effectsPage === 0;
  document.getElementById('next-page').disabled = state.effectsPage >= PAGES - 1;
}

function changePage(dir) {
  goToPage(state.effectsPage + dir);
}

function goToPage(p) {
  if (p < 0 || p >= PAGES) return;
  state.effectsPage = p;
  buildEffectsGrid();
}

function selectEffect(idx) {
  state.effect = idx;
  // Update tile selected states
  document.querySelectorAll('.effect-tile').forEach(t => {
    const isSelected = parseInt(t.dataset.effect) === idx;
    t.classList.toggle('selected', isSelected);
    t.setAttribute('aria-selected', isSelected ? 'true' : 'false');
  });
  // Show/hide distortion controls
  updateDistortionUI();
  // Update effect name
  document.getElementById('current-effect-name').textContent = EFFECTS[idx].name.toUpperCase();
}

function openEffects() {
  state.effectsPanelOpen = true;
  document.getElementById('effects-panel').classList.add('open');
  document.getElementById('effects-btn').classList.add('active');
  buildEffectsGrid();
  tileUpdateIndex = 0;
}

function closeEffects() {
  state.effectsPanelOpen = false;
  document.getElementById('effects-panel').classList.remove('open');
  document.getElementById('effects-btn').classList.remove('active');
}

function updateDistortionUI() {
  const isDistortion = EFFECTS[state.effect].isDistortion;
  const focalPoint = document.getElementById('focal-point');
  const sliderWrap = document.getElementById('distortion-slider-wrap');

  focalPoint.classList.toggle('show', isDistortion);
  sliderWrap.classList.toggle('show', isDistortion);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODE + SHUTTER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setMode(mode) {
  if (state.isRecording) stopRecording();
  state.mode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => {
    const isActive = b.dataset.mode === mode;
    b.classList.toggle('active', isActive);
    b.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });

  const shutter = document.getElementById('shutter-btn');
  shutter.setAttribute('aria-label',
    mode === 'video' ? 'Start recording' : 'Take photo'
  );
}

function triggerShutter() {
  if (state.mode === 'photo') capturePhoto();
  else if (state.mode === '4up') captureFourUp();
  else if (state.mode === 'video') {
    if (state.isRecording) stopRecording();
    else startRecording();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SETTINGS + UI HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleSettings() {
  state.settingsPanelOpen = !state.settingsPanelOpen;
  const panel = document.getElementById('settings-panel');
  panel.classList.toggle('open', state.settingsPanelOpen);
  document.getElementById('settings-btn').classList.toggle('active', state.settingsPanelOpen);
}

function toggleFPS() {
  state.showFPS = !state.showFPS;
  const mon = document.getElementById('fps-monitor');
  mon.style.display = state.showFPS ? 'block' : 'none';
  document.getElementById('fps-toggle-btn').classList.toggle('active', state.showFPS);
}

let aboutOpen = false;
function toggleAbout() {
  aboutOpen = !aboutOpen;
  document.getElementById('about-panel').classList.toggle('open', aboutOpen);
}

// Click outside to close panels
document.addEventListener('click', e => {
  const settings = document.getElementById('settings-panel');
  const settingsBtn = document.getElementById('settings-btn');
  if (state.settingsPanelOpen && !settings.contains(e.target) && !settingsBtn.contains(e.target)) {
    toggleSettings();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FOCAL POINT (DISTORTION CENTER)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.addEventListener('click', e => {
  if (!EFFECTS[state.effect].isDistortion) return;
  updateFocalPoint(e);
});

canvas.addEventListener('pointermove', e => {
  if (e.buttons !== 1 || !EFFECTS[state.effect].isDistortion) return;
  updateFocalPoint(e);
});

function updateFocalPoint(e) {
  const canvasRect = canvas.getBoundingClientRect();
  const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
  // Normalized within canvas DOM element
  const nx = (e.clientX - canvasRect.left) / canvasRect.width;
  const ny = (e.clientY - canvasRect.top) / canvasRect.height;

  // Mirror preview flips X
  state.distortionCenter.x = state.mirrorPreview ? (1 - nx) : nx;
  state.distortionCenter.y = ny;

  // Position focal point indicator relative to canvas-container
  const fp = document.getElementById('focal-point');
  fp.style.left = (e.clientX - containerRect.left) + 'px';
  fp.style.top = (e.clientY - containerRect.top) + 'px';
}

// Distortion amount slider
document.getElementById('distortion-amount').addEventListener('input', e => {
  state.distortionAmount = parseInt(e.target.value) / 100;
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// KEYBOARD SHORTCUTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  // Ignore when typing in inputs
  if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;

  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    if (!state.effectsPanelOpen && !state.viewingIndex >= 0) triggerShutter();
  } else if (e.key === 'ArrowLeft') {
    if (state.effectsPanelOpen) changePage(-1);
    else { state.effect = (state.effect - 1 + EFFECTS.length) % EFFECTS.length; updateDistortionUI(); document.getElementById('current-effect-name').textContent = EFFECTS[state.effect].name.toUpperCase(); }
  } else if (e.key === 'ArrowRight') {
    if (state.effectsPanelOpen) changePage(1);
    else { state.effect = (state.effect + 1) % EFFECTS.length; updateDistortionUI(); document.getElementById('current-effect-name').textContent = EFFECTS[state.effect].name.toUpperCase(); }
  } else if (e.key === 'Escape') {
    if (document.getElementById('viewer-overlay').classList.contains('open')) closeViewer();
    else if (state.effectsPanelOpen) closeEffects();
    else if (state.settingsPanelOpen) toggleSettings();
    else if (aboutOpen) toggleAbout();
  } else if (e.key === 'e' || e.key === 'E') {
    if (state.effectsPanelOpen) closeEffects();
    else openEffects();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UTILITIES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function loadImg(src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = src;
  });
}

async function makeThumbnail(dataURL) {
  const img = await loadImg(dataURL);
  const c = document.createElement('canvas');
  c.width = 160; c.height = 120;
  c.getContext('2d').drawImage(img, 0, 0, 160, 120);
  return c.toDataURL('image/jpeg', 0.7);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  // Open IndexedDB
  try {
    await openDB();
    await loadFromDB();
  } catch (e) {
    console.warn('IndexedDB not available:', e);
  }

  // Set initial effect name
  document.getElementById('current-effect-name').textContent = EFFECTS[0].name.toUpperCase();

  // Start camera
  await initCamera();
}

// Add about toggle to header-right (already in HTML via onclick=toggleAbout())
init();
</script>
</body>
</html>
